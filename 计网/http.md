## GET 和 POST 区别

1. “约定和规范”上的区别，即get用来获取资源，post用来传输数据(增删改)，get参数拼加到URL，post放到请求正文中
2. 缓存，get请求一般会被缓存，常见的css,js,html，而post请求事不进行缓存的
3. 数据量，由于get请求参数是通过url传输的，而url是有长度限制的，通常为2k，post请求参数是放到请求体中的，所以没有限制
4. 安全性，get请求参数放到url，会被保存到历史记录中，性对于post不够安全
5. 参数类型，get请求只允许ascll字符，而post支持更多数据类型（图片，文件，formdata）
6. post会发送两次请求，第一次为options预检请求，状态码为204，预检请求会询问服务器是否支持修改的请求头，检测服务器是否为同源请求,是否支持跨域，第二次为真正的post请求

## Request Header

- Accept:浏览器能够处理的内容类型，（常见为*/*）
- Accept-Charset:浏览器能够显示的字符集
- Accept-Encoding：浏览器能够处理的压缩编码（常见为gzip, deflate）
- Accept-Language：浏览器当前设置的语言（zh-CN,zh;q=0.9）
- Connection：浏览器与服务器之间连接的类型
  - keep-alive  当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
  - close 代表一个Request完成后，客户端和服务器之间用于传输HTTP数据的TCP连接会关闭， 当客户端再次发送Request，需要重新建立TCP连接。
- Cookie：当前页面设置的任何Cookie
- Host：发出请求的页面所在的域
- Referer：发出请求的页面的URL
- User-Agent：浏览器的用户代理字符串（客户端使用的操作系统和浏览器的名称和版本）
- Cache-Control：客户端的缓存策略
  - private 私有的缓存，不能再用户间共享
  - public 响应会被缓存，并且在多用户间共享
  - no-cache 响应不会被缓存,而是实时向服务器端请求资源
  - max-age=10 设置缓存最大的有效时间
  - no-store 在任何条件下，响应都不会被缓存，并且不会被写入到客户端的磁盘里


## Responses Header
- Date：表示消息发送的时间，时间的描述格式由rfc822定义
- server:服务器名称
- Connection：浏览器与服务器之间连接的类型
- Cache-Control：控制HTTP缓存
- Expires：缓存相关，缓存到期时间
- Last-Modified：所请求的对象的最后修改日期
- Content-Length：响应长度，值是字节长度，不是字符长度，Node提供了一个Buffer.byteLength()方法
- content-type:表示后面的文档属于什么MIME类型
  - application/x-www-form-urlencoded：浏览器的原生 form 表单
  - multipart/form-data：常见的 POST 提交方式，表单上传
  - application/json：服务器消息主体是序列化后的 JSON 字符串。
  - text/xml：该种方式主要用来提交 XML 格式的数据。
  

## HTTP 1.0 和 HTTP 1.1 的区别
- 连接方式：1.1默认使用长连接，而1.0默认使用短连接（开启方式`Connection: Keep-alive`）,客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接，下次请求再次建立tcp连接，会造成资源浪费。
- 状态响应码：1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，100 (Continue)​——在请求大资源前的预热请求，206 (Partial Content)​——范围请求的标识码，409 (Conflict)​——请求与当前资源的规定冲突，410 (Gone)——资源已被永久转移，而且没有任何已知的转发地址。
- 缓存处理：在 1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- Host头处理：1.1在请求头中加入了Host字段,用来指定服务器的域名.
- 带宽优化及网络连接的使用，1.1在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。

## HTTP 1.1 和 HTTP 2.0 的区别
- 二进制协议：HTTP/2 是一个二进制协议。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。
- 多路复用： HTTP/2 实现了多路复用，HTTP/2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了"队头堵塞"【1】的问题。
- 数据流： HTTP/2 使用了数据流的概念，因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP/2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。
- 头信息压缩： HTTP/2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP/2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。
- 服务器推送： HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。

## 301 和 302 的区别。
- 301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。

- 他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址；

- 302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。
- SEO302好于301



